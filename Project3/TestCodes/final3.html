<!DOCTYPE html>
<html>
<style>


html, body { height: 100%; width: 100%; margin: 0; }

body {font-family: "Lato", sans-serif;}

#Poll{

  height: 100%;
  width: 100%;
  margin: 0;
}

ul.tab {
    list-style-type: none;
    margin: 0;
    padding: 0;
    overflow: hidden;
    border: 1px solid #ccc;
    background-color: #f1f1f1;
}

/* Float the list items side by side */
ul.tab li {float: left;}

/* Style the links inside the list items */
ul.tab li a {
    display: inline-block;
    color: black;
    text-align: center;
    padding: 14px 16px;
    text-decoration: none;
    transition: 0.3s;
    font-size: 17px;
}

/* Change background color of links on hover */
ul.tab li a:hover {
    background-color: #ddd;
}

/* Create an active/current tablink class */
ul.tab li a:focus, .active {
    background-color: #ccc;
}

/* Style the tab content */
.tabcontent {
    display: none;
    padding: 6px 12px;
    border: 1px solid #ccc;
    border-top: none;
}

/********************************* Roshan **************************/

#bodyContainer{
          width: 100%;
          height: 80%;
          float: left;
          border: 1px solid #555555;
        }

        #leftMenu{
          width: 20%;
          height: 100%;         
          float: left;
          border: 1px solid #555555;
        }

        #svgContainer{
          width: 79%;
          height: 100%;         
          float: right;
          border: 1px solid #555555;
        }

        #mapContainer{
          width: 65%;
          height: 100%;         
          float: left;
          border: 1px solid #555555;
        }

        #forMap{
          width: 100%;
          height: 80%;          
          float: left;
          border: 1px solid #555555;
        }

        #forGraph{
          width: 100%;
          height: 20%;          
          float: left;
          border: 1px solid #555555;
        }

        #graphContainer{
          width: 34%;
          height: 100%;         
          float: right;
          border: 1px solid #555555;
        }



/*************************************/




</style>
<head>
<script type="text/javascript" src="../d3/d3.v3.min.js"> </script>
    <script type="text/javascript" src="../d3/async.js"> </script>
  <link rel="stylesheet" href="../Data/bubble_chart.css">

  <script src="../Data/tooltip.js"></script>
</head>
<body>



<ul class="tab" >
  <li><a href="javascript:void(0)" class="tablinks" onclick="openCity(event, 'HomePage')" id="defaultOpen">Home Page</a></li>
  <li><a href="javascript:void(0)" class="tablinks" onclick="openCity(event, 'Poll')">Poll</a></li>
  <li><a href="javascript:void(0)" class="tablinks" onclick="openCity(event, 'BubbleChart')">Bubble Chart</a></li>
</ul>

<div id="HomePage" class="tabcontent">
  <h3>Home Page</h3>

</div>

<div id="Poll" class="tabcontent">
  <h3>Poll</h3>


    <div id="bodyContainer">
      <div id = "leftMenu"> OPTIONS

        <br>
        <input type="button" value="START" onclick = "start()" > </input>
        <br>
        <input type="button" value="STOP" onclick = "stop()"> </input>
        <br>
        <input type="button" value="RESET" onclick = "reset()"> </input>

      </div>
      <div id = "svgContainer">

        <div id ="mapContainer"> 

          <div id = "forMap"> </div>
          <div id = "forGraph"> </div>

        </div>
        <div id = "graphContainer"> </div>

       </div>
    </div>
   
  <script type="text/javascript">

    //Global Variables

    var allData;
    var onlyUSPolls = [];
    var endDateIsPresent = [];
    var allDates = new Map();
    var allStates = new Map();
    var path;
    var isChartAlreadyDrawn = "NO";
    var isBarAlreadyDrawn = "NO";
    var g1;
    var arc;
    var pie;
    var statesUsed = [];
    var statesUnused = [];
    var counter = 0;
    var isdblClicked = "NO";


    //Setting properties for the svgContainer

    
    var mapSVG = d3.select("#forMap")
              .append("svg")
                .attr("class","mapSVG")
                .attr("width", "100%")
                .attr("height", "100%");


    mapSVG.append("text").attr("id","datetext").attr("x",250).attr("y",20).text("").style("font-size",20)





    

    // var chartSVG = d3.select("#graphContainer")
    //          .append("svg")
    //            .attr("class","chartSVG")
    //            .attr("width", "100%")
    //            .attr("height", "100%");  


    var barChartSVG = d3.select("#forGraph")
              .append("svg")
                .attr("class","barChartSVG")
                .attr("width", "100%")
                .attr("height", "100%");      

                  


      
    // Code for SVG..........................................................
    
      //Width and height of map
      var width = 428;
      var height = 469;
      var allStatesJsonData;
      var map;
      var stateColor;

      
      
      // D3 Projection
      var projection = d3.geo.albersUsa()
                 .translate([330, 190])    // translate to center of screen
                 .scale([750]);          // scale things down so see entire US
              
      // Define path generator
      var path = d3.geo.path()               // path generator that will convert GeoJSON to SVG paths
               .projection(projection);  // tell path generator to use albersUsa projection

          
      // Define linear scale for output
      var color = d3.scale.linear()
              .range(["rgb(213,222,217)","rgb(69,173,168)","rgb(84,36,55)","rgb(217,91,67)"]);


      // Load GeoJSON data and merge with states data
      d3.json("us-states.json", function(error, json) { 
        allStatesJsonData = json;
        // Bind the data to the SVG and create one path per GeoJSON feature
         map = mapSVG.selectAll("path")
              .data(allStatesJsonData.features)
              .enter()
              .append("path")
                .attr("class","map")
                .attr("id", function(d){ 
                  statesUsed.push(d.properties.name.split(' ').join('_'))
                  return d.properties.name.split(' ').join('_');})  
                .attr("d", path)
                .style("stroke", "#fff")
                .style("stroke-width", "1")
                .style("fill", function(d) {    
                  return "rgb(213,222,217)";
                })
      })

      //Loading the poll data

      d3.csv("../Data/presidential_polls.csv", function(error,_data){

        allData = _data;

        allData.forEach(function(d){

          if(allStates[d.state.split(" ").join("_")] === undefined)
          {
            allStates[d.state.split(" ").join("_")] = new Map()


            if (allStates[d.state.split(" ").join("_")][d.enddate] === undefined )
            {
              allStates[d.state.split(" ").join("_")][d.enddate] = [d]
            }
            else
            {
              allStates[d.state.split(" ").join("_")][d.enddate].push(d)
            }
            

          }
          else
          {
            //allStates[d.state.split(" ").join("_")].push(d)
            if (allStates[d.state.split(" ").join("_")][d.enddate] === undefined )
            {
              allStates[d.state.split(" ").join("_")][d.enddate] = [d]
            }
            else
            {
              allStates[d.state.split(" ").join("_")][d.enddate].push(d)
            }

          }

        })// end of allData.forEach()

        colorByDate(allStates)

      }) //end of d3.csv


      function colorByDate(theStates)
      {
        var dates = ["10/1/2016","10/2/2016","10/3/2016","10/4/2016","10/5/2016","10/6/2016","10/7/2016","10/9/2016","10/10/2016","10/11/2016"
              , "10/12/2016","10/13/2016","10/14/2016","10/15/2016","10/16/2016","10/17/2016","10/18/2016","10/19/2016","10/20/2016","10/21/2016"
              ,"10/22/2016","10/23/2016","10/24/2016","10/25/2016","10/26/2016","10/27/2016","10/28/2016","10/29/2016","10/30/2016","10/31/2016"
        ]

        async.eachSeries(dates, function(date,callback){

          d3.selectAll("#datetext").transition().text(date).duration(1000)
          drawSmallMap(date)

          setTimeout(function()
          {
            console.log(date)

            Object.keys(allStates).forEach(function(key){

              d3.selectAll(".map").style("fill","rgb(213,222,217)");
              
              colorStates(date,key)
            })

            if(isdblClicked === "NO")           
              callback();
            else
              callback("stop")
          
          },1500)
          
        }) // end of aynch

      }


      function drawSmallMap(date)
      {
        counter = counter + 1;
        var sMap =d3.select("#graphContainer").append("svg").attr("class","smallSVG").attr("id",date).attr("width",70).attr("height",70)//.append("title").text(date)//.append("text").attr("x",10)
              .attr("y",20).text(date).style("font-size","5px");

        // D3 Projection
        var projection = d3.geo.albersUsa()
                   .translate([35, 35])    // translate to center of screen
                   .scale([100]);          // scale things down so see entire US
                
        // Define path generator
        var path = d3.geo.path()               // path generator that will convert GeoJSON to SVG paths
                 .projection(projection);  // tell path generator to use albersUsa projection

            
        // Define linear scale for output
        var color = d3.scale.linear()
                .range(["rgb(213,222,217)","rgb(69,173,168)","rgb(84,36,55)","rgb(217,91,67)"]);


        // Load GeoJSON data and merge with states data
        d3.json("us-states.json", function(error, json) { 
          allStatesJsonData = json;
          // Bind the data to the SVG and create one path per GeoJSON feature
            sMap.selectAll("path")
                .data(allStatesJsonData.features)
                .enter()
                .append("path")
                  .attr("class","map1")
                  .attr("id", function(d){ 
                    statesUsed.push(d.properties.name.split(' ').join('_'))
                    return d.properties.name.split(' ').join('_') + counter;})  
                  .attr("d", path)
                  .style("stroke", "#fff")
                  .style("stroke-width", "1")
                  .style("fill", function(d) {    
                    return "rgb(213,222,217)";
                  })
                  .on("dblclick", function()
                    {
                      isdblClicked = "YES"
                      Object.keys(allStates).forEach(function(key){

                        d3.selectAll(".map").style("fill","rgb(213,222,217)");
                        d3.select("#datetext").text(date);  

                        colorStates(date,key)

                      })
                    });
        })
      }

      function colorStates(date,key)
      {
                var trumpAvg = 0
                var clintonAvg = 0


              try{

                allStates[key][date].forEach(function (d){

                  trumpAvg = trumpAvg + parseInt(d.rawpoll_trump)
                  clintonAvg = clintonAvg + parseInt(d.rawpoll_clinton)
                })

                // d3.selectAll(".map").style("fill","rgb(213,222,217)");

                drawBarChart(trumpAvg/allStates[key][date].length, clintonAvg/allStates[key][date].length )

                if (trumpAvg/allStates[key][date].length > clintonAvg/allStates[key][date].length )
                {
                  try
                  {
                    d3.selectAll("#" + key.split(" ").join("_")).transition().style("fill","red").duration(1000);
                    //console.log("#" + key.split(" ").join("_") + "_small" + counter)
                    d3.selectAll("#" + key.split(" ").join("_") + counter).transition().style("fill","red").duration(1000);

                  }catch (error)
                  {return;}
                  
                }
                else
                {

                  try
                  {
                    d3.selectAll("#" + key.split(" ").join("_")).transition().style("fill","blue").duration(1000)
                    d3.selectAll("#" + key.split(" ").join("_") + counter).transition().style("fill","blue").duration(1000);
                    
                  }catch (error)
                  {
                    return;

                  }

                }

                

              } catch (error)
              { 

                return;

              }
      }


      


      
      function getColor(theValue)
      {
        if(theValue === "Trump")
          return "red"
        else
          return "#3800ff"
      }


      function drawBarChart(trumpAvg,clintonAvg)
      {
        var totalRectangleWidth = 600;
        var trumpRectWidth = ((trumpAvg / 100) * totalRectangleWidth )
        var clintonRectWidth = ((clintonAvg / 100) * totalRectangleWidth )
        var leftWidth = ((totalRectangleWidth - (trumpRectWidth + clintonRectWidth)) / 2 ) 
        var rectTrump;
        var rectClinton;
        var mapcolor;

        //totalRectangleWidth =  (trumpRectWidth + clintonRectWidth);
        trumpRectWidth = trumpRectWidth + leftWidth;
        clintonRectWidth = clintonRectWidth + leftWidth;

        
        if (trumpRectWidth > clintonRectWidth)
          mapcolor = "red"
        else if(trumpRectWidth < clintonRectWidth)
          mapcolor = "blue"
        else
          mapcolor = "rgb(213,222,217)"
        


        if(isBarAlreadyDrawn === "NO")
        {
          rectTrump = barChartSVG.append("rect")
                      .transition()
                      .attr("class","rectTrump")
                      .attr("x", 10)
                      .attr("y", 40)
                      .attr("height", 20)
                      .attr("width",trumpRectWidth)
                      .style("fill","red")
                      .duration(750)

          barChartSVG.append("text").attr("class","trumpText").attr("x",trumpRectWidth - 65).attr("y",55).style("fill","white")
                      .text("Trump: " + trumpAvg + "%" )
                      
                      

          rectClinton = barChartSVG.append("rect")
                      .transition()
                      .attr("class","rectClinton")
                      .attr("x", (trumpRectWidth+12))
                      .attr("y", 40)
                      //.attr("transform","rotate(180)")
                      .attr("height", 20)
                      .attr("width",(totalRectangleWidth - trumpRectWidth))
                      .style("fill","blue")
                      .duration(750);

          //d3.selectAll(".map").transition().style("fill",mapcolor).duration(1000)

          barChartSVG.append("text").attr("class","clintonText").attr("x",trumpRectWidth+14).attr("y",55).style("fill","white")
                      .text("Clinton: " + clintonAvg + "%" )

          isBarAlreadyDrawn = "YES"
        }
        else
        {
          d3.selectAll(".rectTrump").transition().attr("width",trumpRectWidth).duration(1000);
          d3.selectAll(".rectClinton").transition().attr("x", (trumpRectWidth + 12)).attr("width",(totalRectangleWidth- trumpRectWidth)).duration(1000);
          //d3.selectAll(".map").transition().style("fill",mapcolor).duration(1000);
          d3.selectAll(".trumpText").transition().attr("x", trumpRectWidth - 65).text("Trump: " + trumpAvg + "%" ).duration(1000);
          d3.selectAll(".clintonText").transition().attr("x",trumpRectWidth+14).text("Clinton: " + clintonAvg + "%" ).duration(1000)

        }

        

      } // end of fucntion drawBarChart(_data)



      function drawPieChart(_data)
      {

        //d3.select(".piechart").remove();

        var formattedData = [
                    { legend: "Trump", count: _data.rawpoll_trump},
                    { legend: "Clinton", count: _data.rawpoll_clinton}
                  ];  
      
        var radius = 120;

            arc = d3.svg.arc()
              .innerRadius(100)
              .outerRadius(radius);

            pie = d3.layout.pie()
              .value(function(d) { return d.count; })
              .sort(null);


            if (isChartAlreadyDrawn === "NO")
            {
              g1 = chartSVG.append('g')
                .attr("class","piechart")
                  .attr('transform', 'translate(' + 150 +
                  ',' + 150+ ')');

              path = g1.selectAll('path')
                    .data(pie(formattedData))
                  .enter()
                    .append('path')
                      .attr("class","piePath")
                      .attr('d', arc)
                      .style('fill', function(d) {
                             return getColor(d.data.legend);
                      })
                      .each(function(d) { this._current = d; })
                    .append("title")
                      .text(function(d){ return (d.data.legend);})

                 // remove data not being used
                g1.datum(formattedData).selectAll("path")
                 .data(pie).exit().remove();


                isChartAlreadyDrawn = "YES"

            }
            else
            {
              
              g1.selectAll(".piePath").data(pie(formattedData))
                .transition()
                .attr('d',arc)
                .duration(1500)
                .attrTween("d", arcTween);


              // Store the displayed angles in _current.
          // Then, interpolate from _current to the new angles.
          // During the transition, _current is updated in-place by d3.interpolate.
          function arcTween(a) {
            var i = d3.interpolate(this._current, a);
            this._current = i(0);
            return function(t) {
              return arc(i(t));
            };
          }






            }

            

      }// end of fucntion drawPieChart(_data)


      function stop()
      {
        isdblClicked = "YES";
      }

      function reset()
      {
        stop();

        
        setTimeout(function(d){
          d3.selectAll(".smallSVG").remove();
          isdblClicked = "NO";
          colorByDate(allStates);
          
        },1000)

        
        
      }


      function start()
      {
        isdblClicked = "NO";
      }




    </script>


 
</div>

<div id="BubbleChart" class="tabcontent">
  <h3>Tab3</h3>
  <div class="container">
    <h1>voting rate with unemployment patterns</h1>
    <div id="toolbar">
      <a href="#" id="all" class="button active">All states</a>
      <a href="#" id="year" class="button">By unemployment Rate</a>
    <a href="#" id="turn" class="button">Literacy rate</a>
    <a href="#" id="voter" class="button">voter turn</a>
    <select>
  <option value="2012">2012</option>
  <option value="2016">2016</option>
 
 
</select>
    </div>
    <div id="vis"></div>

    </div>

  <script>

/* bubbleChart creation function. Returns a function that will
 * instantiate a new bubble chart given a DOM element to display
 * it in and a dataset to visualize.
 *
 * counties and style inspired by:
 * https://bost.ocks.org/mike/chart/
 *
 */
function bubbleChart() {
  // Constants for sizing
  var width = 1000;
  var height = 650;

  // tooltip for mouseover functionality
  var tooltip = floatingTooltip('gates_tooltip', 240);

  // Locations to move bubbles towards, depending
  // on which view mode is selected.
  var center = { x: width / 2, y: height / 2 };

  var yearCenters = {
    1: { x:160, y: height / 3 },
    2: { x:270,y: height / 3},
    3: { x:400, y: height / 3 },
  4: { x:566, y: height / 3 },
  5: { x:722, y: height / 3 },
  6: { x:900 , y: height / 3 }
  };
   var yearCenters1 = {
    1: { x:100, y: height / 3 },
    2: { x:270,y: height / 3},
    3: { x:430, y: height / 3 },
  4: { x:570, y: height / 3 },
  5: { x:710, y: height / 3 },
  6: { x:810 , y: height / 3 }
  };
   var yearCenters2 = {
    1: { x:120, y: height / 3 },
    2: { x:270,y: height / 3},
    3: { x:430, y: height / 3 },
  4: { x:570, y: height / 3 },
  5: { x:710, y: height / 3 },
  6: { x:810 , y: height / 3 }
  };

  // X locations of the year titles.
  var yearsTitleX = {
    "less than 5":70,
  ">5 & <=10":270,
    ">10&<=15":470 ,
  ">15&<=20":650,
  ">20&<=25":810,
  ">25":920
  };
  var yearsTitleX1 = {
    "less than 60":70,
  ">60 & <=65":230,
    ">65&<=70":390 ,
  ">70&<=75":525,
  ">75&<=80":670,
  ">80":850
  };
  var yearsTitleX2 = {
    "less than 20":80,
  ">20 & <=40":230,
    ">40&<=60":390 ,
  ">60&<=80":525,
  ">80&<=100":670,
  ">100":850
  };

  // Used when setting up force and
  // moving around nodes
  var damper = 0.102;

  // These will be set in create_nodes and create_vis
  var svg = null;
  var bubbles = null;
  var nodes = [];

  // Charge function that is called for each node.
  // Charge is proportional to the diameter of the
  // circle (which is stored in the radius attribute
  // of the circle's associated data.
  // This is done to allow for accumargin collision
  // detection with nodes of different sizes.
  // Charge is negative because we want nodes to repel.
  // Dividing by 8 scales down the charge to be
  // appropriate for the visualization dimensions.
  function charge(d) {
    return -Math.pow(d.radius, 2.0) / 8;
  }

  // Here we create a force layout and
  // configure it to use the charge function
  // from above. This also sets some contants
  // to specify how the force layout should behave.
  // More configuration is done below.
  var force = d3.layout.force()
    .size([width, height])
    .charge(charge)
    .gravity(-0.01)
    .friction(0.9);


  // Nice looking colors - no reason to buck the trend
  var fillColor = d3.scale.ordinal()
    .domain(['low', 'medium', 'high'])
    .range(['#d84b2a', '#beccae', '#7aa25c']);

  // Sizes bubbles based on their area instead of raw radius
  var radiusScale = d3.scale.pow()
    .exponent(0.8)
    .range([2, 9]);

  /*
   * This data manipulation function takes the raw data from
   * the CSV file and converts it into an array of node objects.
   * Each node will store data and visualization values to visualize
   * a bubble.
   *
   * rawData is expected to be an array of data objects, read in from
   * one of d3's loading functions like d3.csv.
   *
   * This function returns the new node array, with a node in that
   * array for each element in the rawData input.
   */
  function createNodes(rawData) {
    // Use map() to convert raw data into node data.
    // Checkout http://learnjsdata.com/ for more on
    // working with data.
    var myNodes = rawData.map(function (d) {
    var category;
     if(d.rate<=5)
     {
     category =1;
     }
     else if(d.rate>5&&d.rate<=10)
{ category = 2;}
else if(d.rate>10&&d.rate<=15){category=3;}
else if(d.rate>15&&d.rate<=20){category=4;}
else if(d.rate>20&&d.rate<=25){category=5;}
else{ category = 6;}
var category1;
     if(d.lit<=60)
     {
     category1 =1;
     }
else if(d.lit>60&&d.lit<=65){category1=2;}
else if(d.lit>65&&d.lit<=70){category1=3;}
else if(d.lit>70&&d.lit<=75){category1=4;}
else if(d.lit>75&&d.lit<=80){category1=5;}
else{ category1 = 6;}
var category2;
     if(d.voter<=20)
     {
     category2 =1;
     }
else if(d.voter>20&&d.voter<=40){category2=2;}
else if(d.voter>40&&d.voter<=60){category2=3;}
else if(d.voter>60&&d.voter<=80){category2=4;}
else if(d.voter>80&&d.voter<=100){category2=5;}
else{ category2 = 6;}
     return {
        id: d.id,
        radius: radiusScale(+d.margin),
        value: d.margin,
        name: d.state,
        org: d.county,
        group: d.group,
        year:category,
    year1:category1,
    year2:category2,
        x: Math.random() * 900,
    obama:d.obama,
    romney:d.romney,
    rate:d.rate,
    lit:d.lit
      };
    });

    // sort them to prevent occlusion of smaller nodes.
    myNodes.sort(function (a, b) { return b.value - a.value; });

    return myNodes;
  }

  /*
   * Main entry point to the bubble chart. This function is returned
   * by the parent closure. It prepares the rawData for visualization
   * and adds an svg element to the provided selector and starts the
   * visualization creation process.
   *
   * selector is expected to be a DOM element or CSS selector that
   * points to the parent element of the bubble chart. Inside this
   * element, the code will add the SVG continer for the visualization.
   *
   * rawData is expected to be an array of data objects as provided by
   * a d3 loading function like d3.csv.
   */
  var chart = function chart(selector, rawData) {
    // Use the max margin in the data as the max in the scale's domain
    // note we have to ensure the margin is a number by converting it
    // with `+`.
    var maxAmount = d3.max(rawData, function (d) { return +d.margin; });
  //console.log(maxAmount);
    radiusScale.domain([0, maxAmount]);

    nodes = createNodes(rawData);
    // Set the force's nodes to our newly created nodes array.
    force.nodes(nodes);

    // Create a SVG element inside the provided selector
    // with desired size.
    svg = d3.select(selector)
      .append('svg')
      .attr('width', width)
      .attr('height', height);

    // Bind nodes data to what will become DOM elements to represent them.
    bubbles = svg.selectAll('.bubble')
      .data(nodes, function (d) { return d.id; });

    // Create new circle elements each with class `bubble`.
    // There will be one circle.bubble for each object in the nodes array.
    // Initially, their radius (r attribute) will be 0.
    bubbles.enter().append('circle')
      .classed('bubble', true)
      .attr('r', 0)
      .attr('fill', function (d) {
      var value = d.obama;
  //console.log(value)
  var value1 = d.romney;

  if (d.romney>d.obama) {
  //If value exists…
  return "red";
  } else if(d.obama>d.romney) {
  
  return "blue";
  }
  else{
  return "brown"
  }
} ) 
      .attr('stroke', function (d) {
      var value = d.obama;
  //console.log(value)
  var value1 = d.romney;

  if (d.romney>d.obama) {
  //If value exists…
  return "black";
  } else if(d.obama>d.romney) {
  return "black";
  
  }
  else{
  return "brown"
  }
})
      .attr('stroke-width', 2)
      .on('mouseover', showDetail)
      .on('mouseout', hideDetail);

    // Fancy transition to make bubbles appear, ending with the
    // correct radius
    bubbles.transition()
      .duration(500)
      .attr('r', function (d) { return d.radius; });

    // Set initial layout to single group.
    groupBubbles();
  };

  /*
   * Sets visualization in "single group mode".
   * The year labels are hidden and the force layout
   * tick function is set to move all nodes to the
   * center of the visualization.
   */
  function groupBubbles() {
      d3.selectAll(".year").remove();

    force.on('tick', function (e) {
      bubbles.each(moveToCenter(e.alpha))
        .attr('cx', function (d) { return d.x; })
        .attr('cy', function (d) { return d.y; });
    });

    force.start();
  }

  /*
   * Helper function for "single group mode".
   * Returns a function that takes the data for a
   * single node and adjusts the position values
   * of that node to move it toward the center of
   * the visualization.
   *
   * Positioning is adjusted by the force layout's
   * alpha parameter which gets smaller and smaller as
   * the force layout runs. This makes the impact of
   * this moving get reduced as each node gets closer to
   * its destination, and so allows other forces like the
   * node's charge force to also impact final location.
   */
  function moveToCenter(alpha) {
    return function (d) {
      d.x = d.x + (center.x - d.x) * damper * alpha;
      d.y = d.y + (center.y - d.y) * damper * alpha;
    };
  }

  /*
   * Sets visualization in "split by year mode".
   * The year labels are shown and the force layout
   * tick function is set to move nodes to the
   * yearCenter of their data's year.
   */
  function splitBubbles() {
    showYears();
  //conole.log(showYears())
    force.on('tick', function (e) {
      bubbles.each(moveToYears(e.alpha))
        .attr('cx', function (d) { return d.x+25; })
        .attr('cy', function (d) { return d.y+100; });
    });

    force.start();
  }

  /*
   * Helper function for "split by year mode".
   * Returns a function that takes the data for a
   * single node and adjusts the position values
   * of that node to move it the year center for that
   * node.
   *
   * Positioning is adjusted by the force layout's
   * alpha parameter which gets smaller and smaller as
   * the force layout runs. This makes the impact of
   * this moving get reduced as each node gets closer to
   * its destination, and so allows other forces like the
   * node's charge force to also impact final location.
   */
  function moveToYears(alpha) {
    return function (d) {
      var target = yearCenters[d.year];
    //console.log(target.x)
   // console.log(d.x)
      d.x = d.x + (target.x - d.x) * damper * alpha * 3;
    //console.log(d.x)
      d.y = d.y + (target.y - d.y) * damper * alpha * 2.3;
    };
  }//////////////
  
  /*
   * Hides Year title displays.
   */
  /*function hideYears() {
    svg.selectAll('.year').remove();
  }
*/
  /*
   * Shows Year title displays.
   */
  function showYears() {
  
  d3.selectAll(".year").remove();
    // Another way to do this would be to create
    // the year texts once and then just hide them.
    var yearsData = d3.keys(yearsTitleX);
    var years = svg.selectAll('.year')
      .data(yearsData);

    years.enter().append('text')
      .attr('class', 'year')
      .attr('x', function (d) { return yearsTitleX[d]; })
      .attr('y', 40)
      .attr('text-anchor', 'middle')
      .text(function (d) { return d; });
  }


  /*
   * Function called on mouseover to display the
   * details of a bubble in the tooltip.
   */
  function showDetail(d) {
    // change outline to indicate hover state.
    d3.select(this).attr('stroke', 'black');
/*name: d.state,
        org: d.County,*/
    var content = '<span class="name">Title: </span><span class="value">' +
                  d.org +
                  '</span><br/>' +
                  '<span class="name"> unemployment percent: </span><span class="value">' +
                  addCommas(d.rate) +
                  '%</span><br/>';
    tooltip.showTooltip(content, d3.event);
  }

  /*
   * Hides tooltip
   */
  function hideDetail(d) {
    // reset outline
    d3.select(this)
      .attr('stroke', d3.rgb(fillColor(d.group)).darker());

    tooltip.hideTooltip();
  }
  /////////////////////////////////////////////
function splitBubbles2() {
//console.log("split2")
    showYears2();
  //conole.log(showYears())
    force.on('tick', function (e) {
      bubbles.each(moveToYears2(e.alpha))
        .attr('cx', function (d) { return d.x+25; })
        .attr('cy', function (d) { return d.y+100; });
    });

    force.start();
  }
  function moveToYears2(alpha) {
  
    return function (d) {
      var target = yearCenters1[d.year1];
   // console.log(target.x)
    //console.log(d.x)
      d.x = d.x + (target.x - d.x) * damper * alpha * 3;
   // console.log(d.x)
      d.y = d.y + (target.y - d.y) * damper * alpha * 2.3;
    };
  }
  function showYears2() {
  console.log("years");
  d3.selectAll(".year").remove();
    // Another way to do this would be to create
    // the year texts once and then just hide them.
    var yearsData = d3.keys(yearsTitleX1);
    var years= svg.selectAll('.year1')
      .data(yearsData);
//console.log("hello"+years)
    years.enter().append('text')
      .attr('class', 'year')
      .attr('x', function (d) { return yearsTitleX1[d]; })
      .attr('y', 40)
      .attr('text-anchor', 'middle')
      .text(function (d) { return d; });
  }
  function hideYears2() {
    svg.selectAll('.year1').remove();
  }
  function splitBubbles3() {
//console.log("split2")
    showYears3();
  //conole.log(showYears())
    force.on('tick', function (e) {
      bubbles.each(moveToYears3(e.alpha))
        .attr('cx', function (d) { return d.x+25; })
        .attr('cy', function (d) { return d.y+100; });
    });

    force.start();
  }
  function moveToYears3(alpha) {
  
    return function (d) {
      var target = yearCenters1[d.year2];
   // console.log(target.x)
    //console.log(d.x)
      d.x = d.x + (target.x - d.x) * damper * alpha * 3;
   // console.log(d.x)
      d.y = d.y + (target.y - d.y) * damper * alpha * 2.3;
    };
  }
  function showYears3() {
 // console.log("years");
  d3.selectAll(".year").remove();
    // Another way to do this would be to create
    // the year texts once and then just hide them.
    var yearsData = d3.keys(yearsTitleX2);
    var years= svg.selectAll('.year2')
      .data(yearsData);
//console.log("hello"+years)
    years.enter().append('text')
      .attr('class', 'year')
      .attr('x', function (d) { return yearsTitleX2[d]; })
      .attr('y', 40)
      .attr('text-anchor', 'middle')
      .text(function (d) { return d; });
  }
  function hideYears3() {
    svg.selectAll('.year1').remove();
  }
  /*
   * Externally accessible function (this is attached to the
   * returned chart function). Allows the visualization to toggle
   * between "single group" and "split by year" modes.
   *
   * displayName is expected to be a string and either 'year' or 'all'.
   */
  chart.toggleDisplay = function (displayName) {
    if (displayName === 'year') {
      splitBubbles();
    } 
   else if (displayName === 'turn') {
      splitBubbles2();
    } 
  else if(displayName==='voter')
  {
  splitBubbles3();
  }
  else {
      groupBubbles();
    }
  };


  // return the chart function from closure.
  return chart;
}

/*
 * Below is the initialization code as well as some helper functions
 * to create a new bubble chart instance, load the data, and display it.
 */

var myBubbleChart = bubbleChart();

/*
 * Function called once data is loaded from CSV.
 * Calls bubble chart function to display inside #vis div.
 */
function display(error, data) {
  if (error) {
    console.log(error);
  }

  myBubbleChart('#vis', data);
}

/*
 * Sets up the layout buttons to allow for toggling between view modes.
 */
function setupButtons() {
  d3.select('#toolbar')
    .selectAll('.button')
    .on('click', function () {
      // Remove active class from all buttons
      d3.selectAll('.button').classed('active', false);
      // Find the button just clicked
      var button = d3.select(this);

      // Set it as the active button
      button.classed('active', true);

      // Get the id of the button
      var buttonId = button.attr('id');

      // Toggle the bubble chart based on
      // the currently clicked button.
      myBubbleChart.toggleDisplay(buttonId);
    });
}

/*
 * Helper function to convert a number into a string
 * and add commas to it to improve presentation.
 */
function addCommas(nStr) {
  nStr += '';
  var x = nStr.split('.');
  var x1 = x[0];
  var x2 = x.length > 1 ? '.' + x[1] : '';
  var rgx = /(\d+)(\d{3})/;
  while (rgx.test(x1)) {
    x1 = x1.replace(rgx, '$1' + ',' + '$2');
  }

  return x1 + x2;
}

// Load the data.
d3.csv('../Data/gates_money.csv', display);

// setup the buttons.
setupButtons();
</script
</div>

<script>
function openCity(evt, cityName) {
    var i, tabcontent, tablinks;
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
    }
    document.getElementById(cityName).style.display = "block";
    evt.currentTarget.className += " active";
}

// Get the element with id="defaultOpen" and click on it
document.getElementById("defaultOpen").click();
</script>
     
</body>
</html>
